import cv2
import numpy as np
import rospy
import tf2_ros
import tf2_geometry_msgs
from geometry_msgs.msg import PointStamped

# Инициализация ROS
rospy.init_node('color_plate_localization')
tf_buffer = tf2_ros.Buffer()
listener = tf2_ros.TransformListener(tf_buffer)

# Функция для выделения центра цветной пластины в кадре
def find_plate_center(image):
    hsv = cv2.cvtColor(image, cv2.COLOR_BGR2HSV)
    # Порогирование по цвету (зависит от цвета пластины!)
    lower = np.array([H_min, S_min, V_min])
    upper = np.array([H_max, S_max, V_max])
    mask = cv2.inRange(hsv, lower, upper)

    # Поиск контуров
    contours, _ = cv2.findContours(mask, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)
    if not contours:
        return None
    largest_contour = max(contours, key=cv2.contourArea)
    M = cv2.moments(largest_contour)
    if M['m00'] == 0:
        return None
    cx = int(M['m10']/M['m00'])
    cy = int(M['m01']/M['m00'])
    return (cx, cy)

# Здесь должна быть ваша функция для перевода пикселей в координаты камеры
def pixel_to_camera_frame(cx, cy, camera_info, height):
    # camera_info - параметры калибровки камеры
    # height - высота камеры над землей в метрах
    # Пример упрощенного вычисления с предположением, что пластина на высоте 0
    fx = camera_info.K[0]
    fy = camera_info.K[4]
    cx_cam = camera_info.K[2]
    cy_cam = camera_info.K[5]

    # Получаем координаты пластины относительно камеры
    Z = height  # высота камеры над пластиной
    X = (cx - cx_cam) * Z / fx
    Y = (cy - cy_cam) * Z / fy

    # Координаты в системе камеры
    return (X, Y, 0)

# Далее трансформация из camera_link в aruco_map происходит через tf2
def transform_to_aruco_map(point_cam):
    point_stamped = PointStamped()
    point_stamped.header.frame_id = 'camera_link'
    point_stamped.header.stamp = rospy.Time(0)
    point_stamped.point.x = point_cam[0]
    point_stamped.point.y = point_cam[1]
    point_stamped.point.z = point_cam[2]

    try:
        trans = tf_buffer.lookup_transform('aruco_map', 'camera_link', rospy.Time(0), rospy.Duration(1.0))
        point_map = tf2_geometry_msgs.do_transform_point(point_stamped, trans)
        return (point_map.point.x, point_map.point.y, point_map.point.z)
    except Exception as e:
        rospy.logwarn(f"Ошибка трансформации: {e}")
        return None

# Основной цикл
while not rospy.is_shutdown():
    # Получите изображение с камеры (зависит от вашего способа получения)
    image = get_camera_image()
    camera_info = get_camera_info()
    drone_height = get_drone_height()  # по датчику или из tf

    center = find_plate_center(image)
    if center is None:
        rospy.loginfo("Пластина не найдена")
        continue

    point_cam = pixel_to_camera_frame(center[0], center[1], camera_info, drone_height)
    point_map = transform_to_aruco_map(point_cam)

    if point_map:
        rospy.loginfo(f"Пластина в аруко_мап: x={point_map[0]:.2f}, y={point_map[1]:.2f}, z={point_map[2]:.2f}")
